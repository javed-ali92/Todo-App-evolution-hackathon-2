# Data Model: Neon Serverless PostgreSQL Database Migration

**Feature**: 005-neon-db-migration
**Date**: 2026-02-08
**Status**: Complete

## Overview

This document defines the data model for the Todo application using Neon Serverless PostgreSQL. The model consists of three primary entities: User, Task, and Session. All entities are already implemented in SQLModel and require no schema changes for Neon migration.

---

## Entity: User

### Purpose
Represents a registered user account with authentication credentials. Users are the primary actors in the system and own all tasks.

### Attributes

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO INCREMENT | Unique identifier for the user |
| `username` | String(30) | UNIQUE, NOT NULL, 3-30 chars | User's display name |
| `email` | String(255) | UNIQUE, NOT NULL | User's email address for login |
| `hashed_password` | String(255) | NOT NULL | Bcrypt-hashed password |
| `created_at` | Timestamp | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | Timestamp | NOT NULL, DEFAULT NOW() | Last modification timestamp |

### Relationships
- **One-to-Many with Task**: One user can have many tasks (via `task.user_id` foreign key)
- **One-to-Many with Session**: One user can have many active sessions (via `session.user_id` foreign key)

### Constraints
- **UNIQUE** constraint on `username` - No duplicate usernames allowed
- **UNIQUE** constraint on `email` - No duplicate email addresses allowed
- **NOT NULL** on `username`, `email`, `hashed_password` - Required fields
- **CHECK** constraint on `username` length (3-30 characters) - Enforced at application layer

### Validation Rules
- **Username**: 3-30 characters, alphanumeric with underscores allowed
- **Email**: Must be valid email format (validated at application layer)
- **Password**: Minimum 8 characters before hashing (validated at application layer)
- **Hashed Password**: Bcrypt hash with salt (generated by bcrypt library)

### State Transitions
Users have no state transitions. Once created, they remain active. Future enhancements may add:
- Active/Inactive status
- Email verification status
- Account deletion (soft delete)

### Indexes
- **Primary Key Index**: Automatic on `id`
- **Unique Index**: Automatic on `username`
- **Unique Index**: Automatic on `email`
- **Custom Index**: `idx_user_email` on `email` for faster login queries

### SQLModel Implementation
**File**: `backend/src/models/user.py`

```python
class User(UserBase, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    hashed_password: str = Field(nullable=False, min_length=8)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### PostgreSQL Schema
```sql
CREATE TABLE "user" (
    id SERIAL PRIMARY KEY,
    username VARCHAR(30) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    hashed_password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_user_email ON "user"(email);
```

---

## Entity: Task

### Purpose
Represents a todo item belonging to a specific user. Tasks are the core data entity of the application and support various metadata for organization and scheduling.

### Attributes

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO INCREMENT | Unique identifier for the task |
| `user_id` | Integer | FOREIGN KEY → user.id, NOT NULL | Owner of the task |
| `title` | String(200) | NOT NULL, 1-200 chars | Task title/summary |
| `description` | Text | NULLABLE | Detailed task description |
| `due_date` | String(50) | NULLABLE | Due date in ISO format (YYYY-MM-DD) |
| `priority` | Enum | NOT NULL, DEFAULT 'Medium' | Task priority: High, Medium, Low |
| `tags` | Text | NULLABLE | Comma-separated tags for categorization |
| `recursion_pattern` | String(100) | NULLABLE | Recurrence rule (e.g., "daily", "weekly") |
| `completed` | Boolean | NOT NULL, DEFAULT FALSE | Completion status |
| `created_at` | Timestamp | NOT NULL, DEFAULT NOW() | Task creation timestamp |
| `updated_at` | Timestamp | NOT NULL, DEFAULT NOW() | Last modification timestamp |

### Relationships
- **Many-to-One with User**: Many tasks belong to one user (via `user_id` foreign key)

### Constraints
- **FOREIGN KEY** `user_id` REFERENCES `user(id)` ON DELETE CASCADE - Tasks are deleted when user is deleted
- **NOT NULL** on `user_id`, `title`, `completed` - Required fields
- **CHECK** constraint on `priority` - Must be one of: 'High', 'Medium', 'Low'
- **CHECK** constraint on `title` length (1-200 characters) - Enforced at application layer

### Validation Rules
- **Title**: 1-200 characters, required, no leading/trailing whitespace
- **Description**: Optional, unlimited length
- **Due Date**: Optional, ISO format string (YYYY-MM-DD), validated at application layer
- **Priority**: Must be one of: High, Medium, Low (enum enforced at database level)
- **Tags**: Optional, comma-separated string (future: migrate to array type)
- **Recursion Pattern**: Optional, max 100 characters, free-form text
- **Completed**: Boolean, defaults to false

### State Transitions
```
[Created] → completed=false (Initial state)
    ↓
[Incomplete] ↔ [Complete] (Toggle via PATCH /api/{user_id}/tasks/{id}/complete)
    ↓
[Deleted] (Via DELETE /api/{user_id}/tasks/{id})
```

**State Diagram**:
- **Created**: Task is created with `completed=false`
- **Incomplete**: Task exists with `completed=false`
- **Complete**: Task exists with `completed=true`
- **Deleted**: Task is removed from database (hard delete)

**Allowed Transitions**:
- Created → Incomplete (automatic on creation)
- Incomplete → Complete (user marks task as done)
- Complete → Incomplete (user marks task as not done)
- Any state → Deleted (user deletes task)

### Indexes
- **Primary Key Index**: Automatic on `id`
- **Foreign Key Index**: Automatic on `user_id`
- **Custom Index**: `idx_task_user_id` on `user_id` for faster task list queries
- **Custom Index**: `idx_task_completed` on `completed` for filtering completed/incomplete tasks

### SQLModel Implementation
**File**: `backend/src/models/task.py`

```python
class PriorityEnum(str, Enum):
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"

class Task(TaskBase, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### PostgreSQL Schema
```sql
CREATE TYPE priority_enum AS ENUM ('High', 'Medium', 'Low');

CREATE TABLE task (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    due_date VARCHAR(50),
    priority priority_enum NOT NULL DEFAULT 'Medium',
    tags TEXT,
    recursion_pattern VARCHAR(100),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_task_user_id ON task(user_id);
CREATE INDEX idx_task_completed ON task(completed);
```

---

## Entity: Session

### Purpose
Tracks active JWT sessions for logout functionality and session management. Enables token revocation and prevents use of logged-out tokens.

### Attributes

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO INCREMENT | Unique identifier for the session |
| `user_id` | Integer | FOREIGN KEY → user.id, NOT NULL | Session owner |
| `token_jti` | String(255) | UNIQUE, NOT NULL | JWT ID (jti claim) for token identification |
| `token` | String(255) | NOT NULL | Hashed token value for validation |
| `expires_at` | Timestamp | NOT NULL | Token expiration timestamp |
| `revoked` | Boolean | NOT NULL, DEFAULT FALSE | Revocation status |
| `created_at` | Timestamp | NOT NULL, DEFAULT NOW() | Session creation timestamp |

### Relationships
- **Many-to-One with User**: Many sessions belong to one user (via `user_id` foreign key)

### Constraints
- **FOREIGN KEY** `user_id` REFERENCES `user(id)` ON DELETE CASCADE - Sessions are deleted when user is deleted
- **UNIQUE** constraint on `token_jti` - Each JWT must have unique identifier
- **NOT NULL** on `user_id`, `token_jti`, `token`, `expires_at`, `revoked` - Required fields

### Validation Rules
- **Token JTI**: Unique identifier from JWT token, generated by JWT library
- **Token**: Hashed version of the actual JWT token (for security)
- **Expires At**: Must be in the future when session is created
- **Revoked**: Boolean flag, set to true on logout

### State Transitions
```
[Created] → revoked=false, expires_at in future (Initial state)
    ↓
[Active] → revoked=false, expires_at in future (Valid session)
    ↓
[Revoked] → revoked=true (User logged out)
    ↓
[Expired] → expires_at in past (Token expired)
```

**State Diagram**:
- **Created**: Session is created on login
- **Active**: Session is valid and can be used for authentication
- **Revoked**: Session is invalidated by logout
- **Expired**: Session has passed expiration time

**Allowed Transitions**:
- Created → Active (automatic on creation)
- Active → Revoked (user logs out)
- Active → Expired (time passes expiration)
- Revoked/Expired → Deleted (cleanup job, future enhancement)

### Indexes
- **Primary Key Index**: Automatic on `id`
- **Foreign Key Index**: Automatic on `user_id`
- **Unique Index**: Automatic on `token_jti`
- **Custom Index**: `idx_session_token_jti` on `token_jti` for faster session lookups
- **Custom Index**: `idx_session_user_id` on `user_id` for faster user session queries

### SQLModel Implementation
**File**: `backend/src/models/session.py`

```python
class Session(SessionBase, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", nullable=False)
    token_jti: str = Field(unique=True, nullable=False)
    token: str = Field(nullable=False)
    expires_at: datetime = Field(nullable=False)
    revoked: bool = Field(default=False, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### PostgreSQL Schema
```sql
CREATE TABLE session (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    token_jti VARCHAR(255) NOT NULL UNIQUE,
    token VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_session_token_jti ON session(token_jti);
CREATE INDEX idx_session_user_id ON session(user_id);
```

---

## Entity Relationships Diagram

```
┌─────────────────┐
│      User       │
│─────────────────│
│ id (PK)         │
│ username (UQ)   │
│ email (UQ)      │
│ hashed_password │
│ created_at      │
│ updated_at      │
└────────┬────────┘
         │
         │ 1:N
         │
    ┌────┴────┬──────────────┐
    │         │              │
    ▼         ▼              ▼
┌─────────┐ ┌──────────┐ ┌──────────┐
│  Task   │ │ Session  │ │  (Future)│
│─────────│ │──────────│ │──────────│
│ id (PK) │ │ id (PK)  │ │ Comments │
│ user_id │ │ user_id  │ │ Tags     │
│ title   │ │ token_jti│ │ etc.     │
│ ...     │ │ ...      │ │          │
└─────────┘ └──────────┘ └──────────┘
```

---

## Data Integrity Rules

### Referential Integrity
- **User → Task**: ON DELETE CASCADE - Deleting a user deletes all their tasks
- **User → Session**: ON DELETE CASCADE - Deleting a user deletes all their sessions
- **Foreign Key Enforcement**: PostgreSQL enforces all foreign key constraints

### Uniqueness Constraints
- **User.username**: Must be unique across all users
- **User.email**: Must be unique across all users
- **Session.token_jti**: Must be unique across all sessions

### Data Validation
- **Application Layer**: Input validation via Pydantic models (SQLModel)
- **Database Layer**: NOT NULL constraints, CHECK constraints, UNIQUE constraints
- **Business Logic**: Additional validation in service layer (e.g., password strength)

---

## Migration Considerations

### No Schema Changes Required
This migration does not require any schema changes. The existing SQLModel definitions are compatible with both SQLite (previous) and PostgreSQL (Neon).

### Data Type Mapping
SQLModel/SQLAlchemy automatically maps Python types to PostgreSQL types:
- `int` → `INTEGER`
- `str` → `VARCHAR` or `TEXT`
- `bool` → `BOOLEAN`
- `datetime` → `TIMESTAMP`
- `Enum` → `ENUM` type (created automatically)

### Enum Type Handling
PostgreSQL requires explicit ENUM type creation. SQLModel handles this automatically when `create_all()` is called:
```sql
CREATE TYPE priority_enum AS ENUM ('High', 'Medium', 'Low');
```

### Timestamp Handling
- SQLModel uses `datetime.utcnow()` for default timestamps
- PostgreSQL stores as `TIMESTAMP WITHOUT TIME ZONE`
- All timestamps are in UTC (best practice)

---

## Future Enhancements

### Potential Schema Changes
1. **Tags as Array**: Migrate from comma-separated string to PostgreSQL array type
2. **Soft Delete**: Add `deleted_at` timestamp for soft deletion
3. **User Status**: Add `is_active`, `is_verified` flags
4. **Task Categories**: Add separate Category entity with many-to-many relationship
5. **Task Comments**: Add Comment entity for task discussions
6. **Audit Log**: Add audit trail for all data changes

### Performance Optimizations
1. **Composite Indexes**: Add indexes on frequently queried combinations (e.g., `user_id, completed`)
2. **Partial Indexes**: Index only incomplete tasks for faster filtering
3. **Full-Text Search**: Add GIN index on task title/description for search
4. **Materialized Views**: Cache complex queries (e.g., task statistics)

---

## Conclusion

The data model is well-designed and requires no changes for Neon migration. All entities are properly normalized, relationships are clearly defined, and constraints ensure data integrity. The migration is purely an infrastructure change with no schema modifications required.
